"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const P=(e,o)=>o.value,T=(e,o)=>o;function h(e,o,n){return{type:"mutable",initialValue:e,read:P,write:o??T,onObserve:n==null?void 0:n.onObserve,storeLabel:n==null?void 0:n.storeLabel}}function E(e,o,n){return{type:"derived",read:e,write:o,onObserve:n==null?void 0:n.onObserve,storeLabel:n==null?void 0:n.storeLabel}}const L=e=>({type:"callback",write:e}),U=e=>{if(e==="mutable")return h;if(e==="derived")return E;if(e==="callback")return L;throw new Error(`Invalid atom type: ${e}`)},w=e=>e.type==="mutable",N=e=>e.type==="derived",g=e=>e.type==="callback",M=e=>"read"in e,R=e=>"write"in e;var d=(e=>(e.FRESH="fresh",e.STALE="stale",e.PENDING="pending",e))(d||{});const k=e=>{let o=null;const n=new Set,i=()=>Promise.resolve().then(async()=>{await e(n),n.clear(),o=null});return{add:l=>{n.add(l),o||(o=i())},delete:l=>{n.delete(l)},has(l){return n.has(l)},microtaskPromise:o}},I=Symbol("atomValueNotYetCalculcated"),V=e=>w(e)?{value:e.initialValue,dependencies:void 0,derivers:void 0,status:d.FRESH,isObserved:!1,onUnobserve:void 0}:{value:I,dependencies:void 0,derivers:void 0,status:d.STALE,isObserved:!1,onUnobserve:void 0},u=(e,o)=>{const n=o.get(e);if(n)return n;const i=V(e);return o.set(e,i),i},H=(e,o)=>{e.derivers||(e.derivers=new Set),e.derivers.add(o)},F=(e,o)=>{var n,i;(n=e.derivers)==null||n.delete(o),!((i=e.derivers)!=null&&i.size)&&(e.derivers=void 0)},Y=(e,o)=>{e.dependencies||(e.dependencies=new Set),e.dependencies.add(o)},G=()=>{const e=new WeakMap;window.showState=()=>console.log(e);const o=k(t=>{if(!t.size){console.warn("SANITY CHECK IS ACTUALLY NECESSARY??");return}const a=performance.now();t.forEach(s=>{u(s,e).isObserved&&f(s)}),console.log("RECALCULATED",performance.now()-a)}),n=k(async t=>{await o.microtaskPromise;const a=s=>{var A,S;const r=u(s,e);Array.from(r.derivers??[]).some(b=>u(b,e).isObserved)||(console.log("UNOBSERVE",s.storeLabel,r.derivers),(A=r.onUnobserve)==null||A.call(r),r.isObserved=!1,(S=r.dependencies)==null||S.forEach(a))};t.forEach(a)}),i=(t,a)=>{var r;const s=u(t,e);if(s.status!==d.STALE&&(s.status=a),o.has(t)){Array.from(s.derivers??[]).some(c=>!o.has(c))&&console.warn("THIS SHOULD NOT HAPPEN! DERIVERS NOT CORRECTLY MARKED FOR RECALCULATION",t.storeLabel);return}o.add(t),(r=s.derivers)==null||r.forEach(c=>i(c,d.PENDING))},l=(t,a)=>{var r;const s=u(t,e);s.status=d.FRESH,s.value!==a&&((r=s.derivers)==null||r.forEach(c=>i(c,d.STALE)),s.value=a,s.derivers=void 0)},O=t=>{var r;const a=u(t,e);if(a.isObserved||((r=a.dependencies)==null||r.forEach(O),a.isObserved=!0,!t.onObserve))return;const s=R(t)?t.onObserve({peek:v.peekAtom,setSelf:c=>{v.setAtom(t,c)}}):t.onObserve({peek:v.peekAtom});s&&(a.onUnobserve=s)},m=(t,a,s)=>{if(!a)return;(s?a.difference(s):a).forEach(c=>{const A=u(c,e);F(A,t),n.add(c)})},f=(t,a)=>{var S;const s=performance.now(),r=u(t,e);if(a&&O(t),r.status===d.FRESH)return r.value;if(!N(t))throw new Error("Somehow MutableAtom has been marked as not fresh! This shouldn`t be possible!");if(r.status===d.PENDING&&((S=r.dependencies)==null||S.forEach(b=>f(b)),performance.now()-s>1&&console.log("PENDING",performance.now()-s),r.status===d.PENDING))return r.status=d.FRESH,r.value;const c=r.dependencies;r.dependencies=void 0;const A=t.read({get:b=>{const y=f(b,r.isObserved),C=u(b,e);return Y(r,b),H(C,t),y},peek:v.peekAtom,scheduleSet:D},r);return m(t,c,r.dependencies),l(t,A),A},p=(t,a)=>{const s=t.write({peek:v.peekAtom,set:v.setAtom},a);return w(t)&&l(t,s),s},D=(t,a)=>{Promise.resolve().then(()=>p(t,a))},v={peekAtom:t=>f(t),setAtom:p,observeAtom(t,a){const s=E(({get:r})=>{const c=r(t);a(c)},void 0,{storeLabel:`observerOf[${t.storeLabel}]`});return f(s,!0),()=>{n.add(s),v.resetAtom(s)}},resetAtom(t){console.log("RESET ATOM",t.storeLabel)}};return v},W=e=>{const o=h({state:"pending"}),n=E(({get:i,scheduleSet:l})=>(i(e).then(m=>{l(o,{state:"resolved",value:m})}).catch(m=>{l(o,{state:"rejected",error:m})}),null));return E(({get:i})=>(i(n),i(o)))};exports.AtomStateStatus=d;exports.createAtom=U;exports.createCallbackAtom=L;exports.createDerivedAtom=E;exports.createMutableAtom=h;exports.createStore=G;exports.depromisifyAtom=W;exports.isCallbackAtom=g;exports.isDerivedAtom=N;exports.isMutableAtom=w;exports.isReadableAtom=M;exports.isWritableAtom=R;
