"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const g=(e,s)=>s.value,U=(e,s)=>s;function O(e,s,n){return{type:"mutable",initialValue:e,read:g,write:s??U,onObserve:n==null?void 0:n.onObserve,storeLabel:n==null?void 0:n.storeLabel}}function S(e,s,n){return{type:"derived",read:e,write:s,onObserve:n==null?void 0:n.onObserve,storeLabel:n==null?void 0:n.storeLabel}}function h(e){return{type:"observer",read:(...s)=>{e(...s)}}}const N=e=>({type:"callback",write:e}),M=e=>{if(e==="mutable")return O;if(e==="derived")return S;if(e==="observer")return h;if(e==="callback")return N;throw new Error(`Invalid atom type: ${e}`)},w=e=>e.type==="mutable",L=e=>e.type==="derived",R=e=>e.type==="observer",V=e=>L(e)||R(e),I=e=>e.type==="callback",H=e=>"read"in e,C=e=>"write"in e;var i=(e=>(e.FRESH="fresh",e.STALE="stale",e.PENDING="pending",e))(i||{});const D=e=>{let s=null;const n=new Set,c=()=>Promise.resolve().then(async()=>{await e(n),n.clear(),s=null});return{add:l=>{n.add(l),s||(s=c())},delete:l=>{n.delete(l)},has(l){return n.has(l)},microtaskPromise:s}},F=Symbol("atomValueNotYetCalculcated"),Y=e=>w(e)?{value:e.initialValue,dependencies:void 0,dependents:void 0,status:i.FRESH,isObserved:!1,onUnobserve:void 0}:{value:F,dependencies:void 0,dependents:void 0,status:i.STALE,isObserved:!1,onUnobserve:void 0},u=(e,s)=>{const n=s.get(e);if(n)return n;const c=Y(e);return s.set(e,c),c},G=(e,s)=>{e.dependents||(e.dependents=new Set),e.dependents.add(s)},W=(e,s)=>{var n,c;(n=e.dependents)==null||n.delete(s),!((c=e.dependents)!=null&&c.size)&&(e.dependents=void 0)},Q=(e,s)=>{e.dependencies||(e.dependencies=new Set),e.dependencies.add(s)},j=()=>{const e=new WeakMap;window.showState=()=>console.log(e);const s=D(t=>{if(!t.size){console.warn("SANITY CHECK IS ACTUALLY NECESSARY??");return}const a=performance.now();t.forEach(o=>{u(o,e).isObserved&&f(o)}),console.log("RECALCULATED",performance.now()-a)}),n=D(async t=>{await s.microtaskPromise;const a=o=>{var b,p;const r=u(o,e);Array.from(r.dependents??[]).some(m=>u(m,e).isObserved)||(console.log("UNOBSERVE atom",o.storeLabel,r.dependents),(b=r.onUnobserve)==null||b.call(r),r.isObserved=!1,(p=r.dependencies)==null||p.forEach(a))};t.forEach(a)}),c=(t,a)=>{var r;const o=u(t,e);if(o.status!==i.STALE&&(o.status=a),s.has(t)){Array.from(o.dependents??[]).some(d=>!s.has(d))&&console.warn("THIS SHOULD NOT HAPPEN! DEPENDENTS NOT CORRECTLY MARKED FOR RECALCULATION",t.storeLabel);return}s.add(t),(r=o.dependents)==null||r.forEach(d=>c(d,i.PENDING))},l=(t,a)=>{var r;const o=u(t,e);o.status=i.FRESH,o.value!==a&&((r=o.dependents)==null||r.forEach(d=>c(d,i.STALE)),o.value=a,o.dependents=void 0)},E=t=>{var r;const a=u(t,e);if(a.isObserved||((r=a.dependencies)==null||r.forEach(E),a.isObserved=!0,!t.onObserve))return;const o=C(t)?t.onObserve({peek:A.peekAtomValue,setSelf:d=>{A.setAtomValue(t,d)}}):t.onObserve({peek:A.peekAtomValue});o&&(a.onUnobserve=o)},v=(t,a,o)=>{if(!a)return;(o?a.difference(o):a).forEach(d=>{const b=u(d,e);W(b,t),n.add(d)})},f=(t,a)=>{var p;const o=performance.now(),r=u(t,e);if(a&&E(t),r.status===i.FRESH)return r.value;if(!V(t))throw new Error(`Somehow MutableAtom has been marked as not fresh! This shouldn't be possible! - ${t.storeLabel}`);if(r.status===i.PENDING&&((p=r.dependencies)==null||p.forEach(m=>f(m)),performance.now()-o>1&&console.log("PENDING",performance.now()-o),r.status===i.PENDING))return r.status=i.FRESH,r.value;const d=r.dependencies;r.dependencies=void 0;const b=t.read({get:m=>{const P=f(m,r.isObserved),T=u(m,e);return Q(r,m),G(T,t),P},peek:A.peekAtomValue,scheduleSet:y},r);return v(t,d,r.dependencies),l(t,b),b},k=(t,a)=>{const o=t.write({peek:A.peekAtomValue,set:A.setAtomValue},a);return w(t)&&l(t,o),o},y=(t,a)=>{Promise.resolve().then(()=>k(t,a))},A={peekAtomValue:t=>f(t),setAtomValue:k,getAtomState:t=>u(t,e),observeAtomValue(t,a){const o=h(({get:r})=>{const d=r(t);a(d)});return f(o,!0),()=>{n.add(o)}},resetAtomState(t){console.log("RESET ATOM",t.storeLabel)}};return A},z=e=>{const s=O({state:"pending"}),n=S(({get:c,scheduleSet:l})=>(c(e).then(v=>{l(s,{state:"resolved",value:v})}).catch(v=>{l(s,{state:"rejected",error:v})}),null));return S(({get:c})=>(c(n),c(s)))};exports.AtomStateStatus=i;exports.createAtom=M;exports.createCallbackAtom=N;exports.createDerivedAtom=S;exports.createMutableAtom=O;exports.createObserverAtom=h;exports.createStore=j;exports.depromisifyAtom=z;exports.isCallbackAtom=I;exports.isDependentAtom=V;exports.isDerivedAtom=L;exports.isMutableAtom=w;exports.isObserverAtom=R;exports.isReadableAtom=H;exports.isWritableAtom=C;
